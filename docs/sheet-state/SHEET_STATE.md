# Sheet State

This will briefly go over how we handle state in sheets

## State Management

We use the `zustand` library to manage our state, along with the `redux` middleware to be able to interface with it using redux style reducers and dispatch functions. We mostly just use a single store (`useInventoryStore`) in sheets which manages both the state of the sheet inventory and the UI state.

### Resolving Actions

All actions dispatched by `useInventoryStore` are first resolved, and are then acted upon. This is important to make sure we are generating all entity ids client side so our optimistic updates stay consistent with the state on the server.

## Storing Sheet State

When the user loads up the sheet page, the sheets details are fetched in server side rendering and passed to the page as props, from there we pass those details straight into the zustand store.

After the first data fetch, we do not perform any additional data querying for the sheet, all updates to the sheet are sent from the server via websockets.

### Syncing Server State

We have a hook called `useSheetServerSync` which is run just a single time at the top of the sheet page component. This hook is responsible for keeping the client state and server state synchronized, which it does in 2 ways:

**Send Client Updates To The Server:**

As well as the main `useInventoryStore` store, a single other store is used, and that is the `useLastInventoryStoreAction` hook, which is only used within the `useSheetServerSync` hook. This store tracks what the last "resolved action" (see the docs of the "actions" internal lib) that was processed by `useInventoryStore` was, and whenever a new action is dispatched, `useSheetServerSync` will then send that action to the server.

This pattern allows us focus on just writing client state code within the sheet and the process of sending to the server is handled in the background.

**Send Server Updates to the Store:**

`useSheetServerSync` is also subscribed to the sheet's websocket channel. All events sent via that websocket channel will be in the shape of a resolved action, and will have an `actionId` that was generated by the client or perpetuated the mutation.

`useSheetServerSync` sends all actions received over websockets to be dispatched by `useInventoryStore`. `useInventoryStore` keeps track of the `actionId`s of all the actions it has dispatched, so when it receives the websocket update for an event that the client caused, we know we don't have to re-execute it again.
